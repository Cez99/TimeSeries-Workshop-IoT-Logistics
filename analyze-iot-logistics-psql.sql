-- ============================================================================
-- IoT Logistics Fleet Telemetry Workshop (TimescaleDB + PostGIS)
-- ============================================================================
-- Use case:
--   Track telemetry from a fleet of trucks moving cargo between cities.
--   Each truck generates a telemetry + geolocation reading every 5 seconds.
--
-- Default data generation target:
--   - 10,000 trucks
--   - 24 months of history
--   - 1 reading every 5 seconds per truck
--
-- IMPORTANT:
--   The full target dataset is enormous (100B+ rows). This script includes
--   a batch generator to avoid a single massive INSERT. You can edit the
--   constants in the "GENERATOR SETTINGS" block to run smaller demos.
--
-- Run this as plain SQL in any PostgreSQL client connected to TimescaleDB.
-- (No psql meta-commands, no \set, no \echo.)
-- ============================================================================

-- Optional: keep timing on in your client if supported.

-- ============================================================================
-- 1) Extensions
-- ============================================================================
CREATE EXTENSION IF NOT EXISTS timescaledb;
CREATE EXTENSION IF NOT EXISTS postgis;

-- ============================================================================
-- 2) Reset schema (safe for workshop)
-- ============================================================================
DROP MATERIALIZED VIEW IF EXISTS daily_truck_distance_km CASCADE;
DROP MATERIALIZED VIEW IF EXISTS daily_truck_speed CASCADE;

DROP TABLE IF EXISTS truck_telemetry CASCADE;
DROP TABLE IF EXISTS trucks CASCADE;
DROP TABLE IF EXISTS cities CASCADE;

-- ============================================================================
-- 3) Reference data: cities / hubs
-- ============================================================================
CREATE TABLE cities (
  id       INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name     TEXT NOT NULL,
  location GEOGRAPHY(POINT, 4326) NOT NULL
);

-- Edit/replace cities as desired
INSERT INTO cities (name, location) VALUES
  ('Vancouver',     ST_SetSRID(ST_MakePoint(-123.1207, 49.2827), 4326)::geography),
  ('Seattle',       ST_SetSRID(ST_MakePoint(-122.3321, 47.6062), 4326)::geography),
  ('Portland',      ST_SetSRID(ST_MakePoint(-122.6765, 45.5231), 4326)::geography),
  ('San Francisco', ST_SetSRID(ST_MakePoint(-122.4194, 37.7749), 4326)::geography),
  ('Los Angeles',   ST_SetSRID(ST_MakePoint(-118.2437, 34.0522), 4326)::geography),
  ('Las Vegas',     ST_SetSRID(ST_MakePoint(-115.1398, 36.1699), 4326)::geography),
  ('Phoenix',       ST_SetSRID(ST_MakePoint(-112.0740, 33.4484), 4326)::geography),
  ('Denver',        ST_SetSRID(ST_MakePoint(-104.9903, 39.7392), 4326)::geography),
  ('Chicago',       ST_SetSRID(ST_MakePoint(-87.6298, 41.8781), 4326)::geography),
  ('Dallas',        ST_SetSRID(ST_MakePoint(-96.7970, 32.7767), 4326)::geography);

-- ============================================================================
-- 4) Fleet metadata
-- ============================================================================
CREATE TABLE trucks (
  id             INTEGER PRIMARY KEY,
  origin_city_id INTEGER NOT NULL REFERENCES cities(id),
  dest_city_id   INTEGER NOT NULL REFERENCES cities(id),
  -- deterministic per truck so generation is stable across batches
  seed           DOUBLE PRECISION NOT NULL
);

-- Create 10,000 trucks with a deterministic origin/destination assignment
INSERT INTO trucks (id, origin_city_id, dest_city_id, seed)
SELECT
  t AS id,
  ((t % (SELECT count(*) FROM cities)) + 1) AS origin_city_id,
  (((t + 3) % (SELECT count(*) FROM cities)) + 1) AS dest_city_id,
  (('x'||substr(md5(t::text),1,8))::bit(32)::int / 2147483647.0) AS seed
FROM generate_series(1, 10000) AS g(t);

-- ============================================================================
-- 5) Telemetry hypertable (telemetry + geolocation every 5 seconds)
-- ============================================================================
CREATE TABLE truck_telemetry (
  time           TIMESTAMPTZ NOT NULL,
  truck_id       INTEGER      NOT NULL REFERENCES trucks(id),

  -- Geospatial location (meters-based distance with geography)
  location       GEOGRAPHY(POINT, 4326) NOT NULL,

  -- Operational telemetry
  speed_kph      DOUBLE PRECISION NOT NULL,
  heading_deg    DOUBLE PRECISION NOT NULL,
  engine_temp_c  DOUBLE PRECISION NOT NULL,
  fuel_pct       DOUBLE PRECISION NOT NULL,
  cargo_kg       DOUBLE PRECISION NOT NULL,

  -- Route context (denormalized for convenience)
  origin_city_id INTEGER NOT NULL,
  dest_city_id   INTEGER NOT NULL
);

SELECT create_hypertable('truck_telemetry', 'time');

CREATE INDEX truck_telemetry_truck_time_idx ON truck_telemetry (truck_id, time DESC);
CREATE INDEX truck_telemetry_location_gist ON truck_telemetry USING GIST (location);

-- ============================================================================
-- 6) Movement model (pure SQL) - route point interpolation
-- ============================================================================
-- Approximate movement as repeated trips from origin->dest, looping forever.
-- Trip duration varies per truck (deterministic) to avoid identical motion.
CREATE OR REPLACE FUNCTION truck_route_point(
  p_truck_id INT,
  p_time TIMESTAMPTZ,
  p_start_time TIMESTAMPTZ
) RETURNS GEOGRAPHY(POINT,4326)
LANGUAGE SQL
STABLE
AS $$
WITH t AS (
  SELECT
    tr.seed,
    c1.location AS origin,
    c2.location AS dest
  FROM trucks tr
  JOIN cities c1 ON c1.id = tr.origin_city_id
  JOIN cities c2 ON c2.id = tr.dest_city_id
  WHERE tr.id = p_truck_id
),
params AS (
  SELECT
    -- trip duration: 4h..16h
    (14400 + (t.seed * 43200))::DOUBLE PRECISION AS trip_seconds
  FROM t
),
progress AS (
  SELECT
    mod(extract(epoch from (p_time - p_start_time)), params.trip_seconds) / params.trip_seconds AS frac
  FROM params
),
line AS (
  SELECT
    ST_MakeLine(t.origin::geometry, t.dest::geometry) AS geom_line,
    progress.frac AS frac,
    t.seed AS seed
  FROM t, progress
),
pt AS (
  SELECT
    ST_LineInterpolatePoint(geom_line, frac) AS base_pt,
    seed
  FROM line
),
jitter AS (
  SELECT
    -- small jitter to reduce overplotting (roughly tens of meters)
    ST_Translate(
      base_pt,
      (seed - 0.5) * 0.0005,
      ((seed * 1.7) - 0.5) * 0.0005
    ) AS geom_pt
  FROM pt
)
SELECT ST_SetSRID(geom_pt,4326)::geography
FROM jitter;
$$;

-- ============================================================================
-- 7) Generate synthetic telemetry (batched)
-- ============================================================================
-- GENERATOR SETTINGS (edit these constants for smaller runs)
--   total_months_back: 24
--   step_seconds: 5
--   batch_days: 1           (time window per insert)
--   batch_trucks: 1000      (truck window per insert)
--
-- Tip for demos:
--   - set total_months_back to 1
--   - set batch_trucks to 200
--   - optionally increase step_seconds to 10 or 30
DO $$
DECLARE
  total_months_back INT := 24;
  step_seconds      INT := 5;

  batch_days        INT := 1;
  batch_trucks      INT := 1000;

  start_ts TIMESTAMPTZ := now() - make_interval(months => total_months_back);
  end_ts   TIMESTAMPTZ := now();

  batch_start TIMESTAMPTZ;
  batch_end   TIMESTAMPTZ;

  truck_start INT;
  truck_end   INT;

  total_trucks INT := 10000;
BEGIN
  batch_start := start_ts;

  WHILE batch_start < end_ts LOOP
    batch_end := LEAST(batch_start + make_interval(days => batch_days), end_ts);

    truck_start := 1;
    WHILE truck_start <= total_trucks LOOP
      truck_end := LEAST(truck_start + batch_trucks - 1, total_trucks);

      INSERT INTO truck_telemetry (
        time, truck_id, location,
        speed_kph, heading_deg, engine_temp_c, fuel_pct, cargo_kg,
        origin_city_id, dest_city_id
      )
      SELECT
        ts AS time,
        tr.id AS truck_id,
        truck_route_point(tr.id, ts, start_ts) AS location,

        -- Operational telemetry ranges
        40 + (70 * random()) + (tr.seed * 5) AS speed_kph,     -- ~40..115
        (random() * 360.0) AS heading_deg,                      -- 0..360
        70 + (random() * 40.0) AS engine_temp_c,                -- 70..110
        GREATEST(5.0, 100.0 - (random() * 95.0)) AS fuel_pct,   -- 5..100
        (random() * 20000.0) AS cargo_kg,                       -- 0..20000

        tr.origin_city_id,
        tr.dest_city_id
      FROM generate_series(batch_start, batch_end, make_interval(secs => step_seconds)) AS g(ts)
      JOIN trucks tr ON tr.id BETWEEN truck_start AND truck_end;

      truck_start := truck_end + 1;
    END LOOP;

    batch_start := batch_end;
  END LOOP;
END $$;

ANALYZE truck_telemetry;

-- ============================================================================
-- 8) Quick sanity checks
-- ============================================================================
SELECT * FROM truck_telemetry ORDER BY time DESC LIMIT 10;

-- Hypertable chunk overview (requires TimescaleDB informational views)
SELECT chunk_name, range_start, range_end, is_compressed
FROM timescaledb_information.chunks
WHERE hypertable_name = 'truck_telemetry'
ORDER BY range_start DESC
LIMIT 15;

-- ============================================================================
-- 9) Analytics: time-series + geospatial queries
-- ============================================================================
-- 9.1) Latest known position per truck (sample)
SELECT DISTINCT ON (truck_id)
  truck_id, time, location, speed_kph, fuel_pct
FROM truck_telemetry
ORDER BY truck_id, time DESC
LIMIT 25;

-- 9.2) Daily rollup: avg speed + max cargo per truck (recent)
SELECT
  time_bucket('1 day', time) AS day,
  truck_id,
  ROUND(AVG(speed_kph)::numeric, 2) AS avg_speed_kph,
  ROUND(MAX(cargo_kg)::numeric, 2)  AS max_cargo_kg,
  COUNT(*) AS readings
FROM truck_telemetry
WHERE time >= now() - interval '7 days'
GROUP BY day, truck_id
ORDER BY day DESC, avg_speed_kph DESC
LIMIT 50;

-- 9.3) Geofence: trucks inside a polygon during a time window (Seattle-ish)
WITH fence AS (
  SELECT ST_GeomFromText(
    'POLYGON((-122.36 47.58,-122.36 47.66,-122.28 47.66,-122.28 47.58,-122.36 47.58))',
    4326
  )::geography AS poly
)
SELECT
  time, truck_id
FROM truck_telemetry, fence
WHERE time >= now() - interval '30 minutes'
  AND ST_Contains(fence.poly::geometry, truck_telemetry.location::geometry)
ORDER BY time DESC
LIMIT 200;

-- 9.4) Proximity: trucks within N km of a depot/city (Vancouver within 25 km)
WITH depot AS (
  SELECT location AS city_loc
  FROM cities
  WHERE name = 'Vancouver'
),
recent AS (
  SELECT *
  FROM truck_telemetry
  WHERE time >= now() - interval '1 hour'
)
SELECT
  recent.time,
  recent.truck_id,
  ROUND(ST_Distance(recent.location, depot.city_loc)/1000.0, 2) AS km_from_vancouver
FROM recent, depot
WHERE ST_DWithin(recent.location, depot.city_loc, 25000) -- meters
ORDER BY recent.time DESC
LIMIT 200;

-- 9.5) Distance traveled per truck per day (sum of segment distances)
WITH daily AS (
  SELECT
    time_bucket('1 day', time) AS day,
    truck_id,
    time,
    location
  FROM truck_telemetry
  WHERE time >= now() - interval '7 days'
),
segments AS (
  SELECT
    day,
    truck_id,
    time,
    ST_Distance(
      location,
      LAG(location) OVER (PARTITION BY day, truck_id ORDER BY time)
    ) AS meters
  FROM daily
)
SELECT
  day,
  truck_id,
  ROUND(SUM(COALESCE(meters,0))/1000.0, 2) AS km_traveled
FROM segments
GROUP BY day, truck_id
ORDER BY day DESC, km_traveled DESC
LIMIT 50;

-- 9.6) Distance from origin city (latest point)
WITH origin AS (
  SELECT tr.id AS truck_id, c.location AS origin_loc
  FROM trucks tr
  JOIN cities c ON c.id = tr.origin_city_id
),
latest AS (
  SELECT DISTINCT ON (truck_id)
    truck_id, time, location
  FROM truck_telemetry
  ORDER BY truck_id, time DESC
)
SELECT
  latest.truck_id,
  latest.time,
  ROUND(ST_Distance(latest.location, origin.origin_loc)/1000.0, 2) AS km_from_origin
FROM latest
JOIN origin ON origin.truck_id = latest.truck_id
ORDER BY km_from_origin DESC
LIMIT 50;

-- 9.7) Geofence entry events in last day (entered polygon)
WITH fence AS (
  SELECT ST_GeomFromText(
    'POLYGON((-122.36 47.58,-122.36 47.66,-122.28 47.66,-122.28 47.58,-122.36 47.58))',
    4326
  )::geography AS poly
),
events AS (
  SELECT
    truck_id,
    time,
    ST_Contains(fence.poly::geometry, location::geometry) AS inside,
    LAG(ST_Contains(fence.poly::geometry, location::geometry))
      OVER (PARTITION BY truck_id ORDER BY time) AS was_inside
  FROM truck_telemetry, fence
  WHERE time >= now() - interval '1 day'
)
SELECT *
FROM events
WHERE inside = true AND (was_inside = false OR was_inside IS NULL)
ORDER BY time DESC
LIMIT 200;

-- ============================================================================
-- 10) Compression + Continuous Aggregates
-- ============================================================================
-- Automatically compress chunks older than 7 days
-- (If you prefer manual compression, comment this out.)
CALL add_columnstore_policy('truck_telemetry', after => INTERVAL '7d');

-- Continuous aggregate: daily distance traveled per truck (km)
CREATE MATERIALIZED VIEW daily_truck_distance_km
WITH (timescaledb.continuous, timescaledb.materialized_only = false) AS
WITH daily AS (
  SELECT
    time_bucket('1 day', time) AS day,
    truck_id,
    time,
    location
  FROM truck_telemetry
),
segments AS (
  SELECT
    day,
    truck_id,
    time,
    ST_Distance(
      location,
      LAG(location) OVER (PARTITION BY day, truck_id ORDER BY time)
    ) AS meters
  FROM daily
)
SELECT
  day,
  truck_id,
  SUM(COALESCE(meters,0))/1000.0 AS km_traveled
FROM segments
GROUP BY day, truck_id;

SELECT add_continuous_aggregate_policy(
  'daily_truck_distance_km',
  start_offset => INTERVAL '14 days',
  end_offset   => INTERVAL '1 day',
  schedule_interval => INTERVAL '1 day'
);

-- Continuous aggregate: daily speed stats per truck
CREATE MATERIALIZED VIEW daily_truck_speed
WITH (timescaledb.continuous, timescaledb.materialized_only = false) AS
SELECT
  time_bucket('1 day', time) AS day,
  truck_id,
  AVG(speed_kph) AS avg_speed_kph,
  MAX(speed_kph) AS max_speed_kph,
  COUNT(*) AS readings
FROM truck_telemetry
GROUP BY day, truck_id;

SELECT add_continuous_aggregate_policy(
  'daily_truck_speed',
  start_offset => INTERVAL '14 days',
  end_offset   => INTERVAL '1 day',
  schedule_interval => INTERVAL '1 day'
);

-- Query continuous aggregates (last 7 days)
SELECT *
FROM daily_truck_distance_km
WHERE day >= now() - interval '7 days'
ORDER BY day DESC, km_traveled DESC
LIMIT 50;

SELECT *
FROM daily_truck_speed
WHERE day >= now() - interval '7 days'
ORDER BY day DESC, avg_speed_kph DESC
LIMIT 50;

-- Retention example (commented out)
-- SELECT add_retention_policy('truck_telemetry', INTERVAL '730 days');
